use yasysyc::ast::*;

grammar;

match {
    // skip whitespaces
    r"\s*" => {},

    // skip line comments
    r"//[^\n\r]*[\n\r]*" => {},

    // skip block comments
    r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {},

    // process other tokens as normal
    _
}

pub CompUnit: CompUnit = <func_def: FuncDef> => CompUnit { func_def };

FuncDef: FuncDef = {
    <func_type: FuncType> <id: Ident> "(" ")" <block: Block> => {
        FuncDef { func_type, id, block }
    }
}

FuncType: FuncType = "int" => FuncType::Int;
Block: Block = "{" <stmt: Stmt> "}" => Block { stmt };
Stmt: Stmt = "return" <expr: Expr> ";" => Stmt::Return(ReturnStmt { expr });

Expr: Expr = AddExpr;

AddExpr: Expr = {
    MulExpr,
    <e1: AddExpr> "+" <e2: MulExpr> => Expr::Binary(Box::new(e1), BinaryOp::Add, Box::new(e2)),
    <e1: AddExpr> "-" <e2: MulExpr> => Expr::Binary(Box::new(e1), BinaryOp::Sub, Box::new(e2)),
}

MulExpr: Expr = {
    UnaryExpr,
    <e1: MulExpr> "*" <e2: UnaryExpr> => Expr::Binary(Box::new(e1), BinaryOp::Mul, Box::new(e2)),
    <e1: MulExpr> "/" <e2: UnaryExpr> => Expr::Binary(Box::new(e1), BinaryOp::Div, Box::new(e2)),
    <e1: MulExpr> "%" <e2: UnaryExpr> => Expr::Binary(Box::new(e1), BinaryOp::Mod, Box::new(e2)),
}

UnaryExpr: Expr = {
    PrimaryExpr,
    <op: UnaryOp> <expr: UnaryExpr> => Expr::Unary(op, Box::new(expr)),
}

PrimaryExpr: Expr = {
    <IntConst> => Expr::Number(<>),
    "(" <Expr> ")" => <>
}

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::Not,
}

Ident: Ident = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string().into();
IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}